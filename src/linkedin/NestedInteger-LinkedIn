/**
 * Given a nested list of integers, returns the sum of all integers in the list weighted by their reversed depth.
 * For example, given the list {{1,1},2,{1,1}} the deepest level is 2. Thus the function should return 8 (four 1's with weight 1, one 2 with weight 2)
 * Given the list {1,{4,{6}}} the function should return 17 (one 1 with weight 3, one 4 with weight 2, and one 6 with weight 1)
 */

 
 List<NestedInteger> input
 
 NestedInteger -> [1,1]   (1)
      NestedInteger 1  (2) 
      NestedInteger 1  (2)     
      
 NestedInteger -> 2       (1)
 
 NestedInteger -> [1,1]   (1) 
     NestedInteger  1  (2)
     NestedInteger  1  (2)
 
 ----------------------
 NestedInteger --> 1           (3)

 NestedInteger --> [4, {6}]    (1)
     NestedInteger --> 4       (2)
     NestedInteger --> {6}    
       NestedInteger --> 6     (1)
                     
                
 

 public int reverseDepthSum (List<NestedInteger> input)
{
    int sum = execNestedSet(input, 1);
}

//recursive
public int execNestedSet(List<NestedInteger> inputl){

   if(inputl == null ) return 0;
    
   NestedInteger ni =   inputl.get(0);  
   
   if(!ni.isInteger())  execNestedSet(inputl.get(1));
}


 
/**
 * This is the interface that represents nested lists.
 * You should not implement it, or speculate about its implementation.
 */
public interface NestedInteger
{
    /** @return true if this NestedInteger holds a single integer, rather than a nested list */
    boolean isInteger();
 
    /** @return the single integer that this NestedInteger holds, if it holds a single integer
     * Return null if this NestedInteger holds a nested list */
    Integer getInteger();
 
    /** @return the nested list that this NestedInteger holds, if it holds a nested list
     * Return null if this NestedInteger holds a single integer */
    List<NestedInteger> getList();
}
